// server.js
import express from "express";
import bodyParser from "body-parser";
import cors from "cors";
import sqlite3 from "sqlite3";
import { open } from "sqlite";
import path from "path";
import { fileURLToPath } from "url";
import bcrypt from "bcrypt";
import nodemailer from "nodemailer";
import dotenv from "dotenv";

dotenv.config();

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const app = express();
app.use(cors());
app.use(bodyParser.json());
// Serve frontend (simon folder on Desktop)
app.use("/", express.static(path.join(__dirname, "../simon")));

// Serve admin panel
app.use("/admin", express.static(path.join(__dirname, "public")));

/*****************************************************
 * ðŸ” ADMIN AUTH MIDDLEWARE
 *****************************************************/
function adminAuth(req, res, next) {
  const pass = req.headers["x-admin-pass"];
  if (!process.env.ADMIN_PASSWORD) {
    return res.status(500).json({ success: false, message: "Admin password not configured" });
  }
  if (!pass || pass !== process.env.ADMIN_PASSWORD) {
    return res.status(401).json({ success: false, message: "Unauthorized (admin)" });
  }
  next();
}

/*****************************************************
 * ðŸ“§ NODEMAILER TRANSPORTER (GMAIL)
 *****************************************************/
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.GMAIL_USER,
    pass: process.env.GMAIL_PASS,
  },
});

/*****************************************************
 * ðŸ’¾ DATABASE INITIALIZATION
 *****************************************************/
const db = await open({
  filename: "./database.sqlite",
  driver: sqlite3.Database,
});

// Create necessary tables
await db.exec(`
CREATE TABLE IF NOT EXISTS codes (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  code TEXT UNIQUE,
  created_at INTEGER,
  expires_at INTEGER,
  used INTEGER DEFAULT 0
);
`);

await db.exec(`
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  fullname TEXT,
  email TEXT UNIQUE,
  username TEXT UNIQUE,
  password TEXT,
  country TEXT,
  phone TEXT,
  created_at INTEGER,
  total_balance REAL DEFAULT 0,
  affiliate_balance REAL DEFAULT 0,
  bonus_balance REAL DEFAULT 0
);
`);

await db.exec(`
CREATE TABLE IF NOT EXISTS withdrawals (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT,
  amount REAL,
  bank_name TEXT,
  account_number TEXT,
  status TEXT DEFAULT 'pending',
  requested_at INTEGER
);
`);

await db.exec(`
CREATE TABLE IF NOT EXISTS transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT,
  type TEXT,
  amount REAL,
  balance_after REAL,
  note TEXT,
  created_at INTEGER
);
`);

await db.exec(`
CREATE TABLE IF NOT EXISTS wallet_logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT,
  amount REAL,
  type TEXT, -- credit or debit
  description TEXT,
  change REAL,
  reason TEXT,
  created_at INTEGER
);
`);

/*****************************************************
 * ðŸ§© HELPER FUNCTIONS
 *****************************************************/
function generateCode(length = 6) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  return Array.from({ length }, () => chars[Math.floor(Math.random() * chars.length)]).join("");
}

function sendEmail(to, subject, html) {
  return transporter.sendMail({
    from: `"Nexa Admin" <${process.env.GMAIL_USER}>`,
    to,
    subject,
    html,
  });
}

/*****************************************************
 * ðŸ§¾ CODE GENERATOR (ADMIN)
 *****************************************************/
app.post("/api/generate", async (req, res) => {
  try {
    const length = parseInt(req.body.length) || 6;
    const code = generateCode(length);
    const now = Date.now();
    const expiresAt = now + 24 * 60 * 60 * 1000; // 24 hrs

    await db.run("INSERT INTO codes (code, created_at, expires_at) VALUES (?, ?, ?)", [
      code,
      now,
      expiresAt,
    ]);

    res.json({ code, expiresAt });
  } catch (err) {
    console.error("Code generation error:", err);
    res.status(500).json({ success: false, message: "Database error while generating code" });
  }
});

app.get("/api/list", async (req, res) => {
  const rows = await db.all("SELECT * FROM codes ORDER BY id DESC");
  res.json(rows);
});

app.delete("/api/cleanup", async (req, res) => {
  const now = Date.now();
  await db.run("DELETE FROM codes WHERE expires_at < ? OR used = 1", [now]);
  res.json({ ok: true });
});

// NOTE: verify only checks validity and DOES NOT mark code used
app.post("/api/verify", async (req, res) => {
  const { code } = req.body;
  if (!code)
    return res.status(400).json({ valid: false, reason: "missing_code" });

  const row = await db.get("SELECT * FROM codes WHERE code = ?", [code]);
  if (!row)
    return res.json({ valid: false, reason: "not_found" });
  if (Date.now() > row.expires_at)
    return res.json({ valid: false, reason: "expired" });
  if (row.used)
    return res.json({ valid: false, reason: "already_used" });

  // Only confirm validity here
  return res.json({ valid: true });
});

/*****************************************************
 * ðŸ‘¤ USER AUTHENTICATION + REFERRALS
 *****************************************************/
app.post("/api/signup", async (req, res) => {
  const { fullname, email, username, password, country, phone, code, ref } = req.body;
  if (!fullname || !email || !username || !password || !code)
    return res.status(400).json({ error: "Missing required fields" });

  // Validate access code
  const codeRow = await db.get("SELECT * FROM codes WHERE code = ?", [code]);
  if (!codeRow) return res.json({ success: false, message: "Invalid access code" });
  if (Date.now() > codeRow.expires_at)
    return res.json({ success: false, message: "Access code expired" });
  if (codeRow.used)
    return res.json({ success: false, message: "Access code already used" });

  const hashed = await bcrypt.hash(password, 10);

  try {
    // Create user
    await db.run(
      "INSERT INTO users (fullname, email, username, password, country, phone, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
      [fullname, email, username, hashed, country, phone, Date.now()]
    );

    // Mark the access code as used only after successful registration
    await db.run("UPDATE codes SET used = 1 WHERE id = ?", [codeRow.id]);

    /*****************************************************
     * ðŸ’¸ REFERRAL LOGIC â€” reward â‚¦6,000 to referrer
     * - Credit both total_balance (so it appears in wallet)
     * - Increment affiliate_balance (so referral earnings tracked)
     * - Insert transaction + wallet_log
     *****************************************************/
    if (ref) {
      try {
        const refUser = await db.get(
  "SELECT username, affiliate_balance, email FROM users WHERE LOWER(username) = LOWER(?)",
  [ref]
);


        if (refUser) {
          const prevTotal = Number(refUser.total_balance || 0);
          const prevAffiliate = Number(refUser.affiliate_balance || 0);
          const reward = 6000;

          const newTotal = prevTotal + reward;
          const newAffiliate = prevAffiliate + reward;

          // Update referrer's balances
          await db.run(
            "UPDATE users SET total_balance = ?, affiliate_balance = ? WHERE username = ?",
            [newTotal, newAffiliate, ref]
          );

          // Record transaction for referrer
          await db.run(
            "INSERT INTO transactions (username, type, amount, balance_after, note, created_at) VALUES (?, ?, ?, ?, ?, ?)",
            [ref, "referral_bonus", reward, newTotal, `Referral bonus from ${username}`, Date.now()]
          );

          // Record wallet log for referrer
          await db.run(
            "INSERT INTO wallet_logs (username, amount, type, description, change, reason, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
            [ref, reward, "credit", `Referral bonus for inviting ${username}`, reward, `referral:${username}`, Date.now()]
          );

          // Optional: Email referrer
          if (refUser.email) {
            const subject = "ðŸŽ‰ You earned a referral bonus!";
            const html = `
              <p>Hello ${refUser.username},</p>
              <p>Good news â€” you received â‚¦${reward.toLocaleString()} as a referral bonus because <strong>${username}</strong> signed up using your link.</p>
              <p>Your new balance is â‚¦${newTotal.toFixed(2)}.</p>
              <p>Thanks for referring a user!</p>
            `;
            sendEmail(refUser.email, subject, html).catch(err => console.error("Referral email error:", err));
          }
        }
      } catch (refErr) {
        console.error("Referral processing error:", refErr);
        // Don't fail signup because of referral email/logging issues â€” continue
      }
    }

    res.json({ success: true, message: "User registered successfully!" });
  } catch (err) {
    if (err.message && err.message.includes("UNIQUE")) {
      res.json({ success: false, message: "Email or username already exists" });
    } else {
      console.error("Signup error:", err);
      res.status(500).json({ success: false, message: "Server error" });
    }
  }
});

app.post("/api/login", async (req, res) => {
  const { username, password } = req.body;
  if (!username || !password)
    return res.json({ success: false, message: "Missing credentials" });

  const user = await db.get("SELECT * FROM users WHERE username = ?", [username]);
  if (!user) return res.json({ success: false, message: "User not found" });

  const valid = await bcrypt.compare(password, user.password);
  if (!valid) return res.json({ success: false, message: "Invalid password" });

  res.json({
    success: true,
    message: "Login successful",
    user: {
      id: user.id,
      fullname: user.fullname,
      username: user.username,
      email: user.email,
      country: user.country,
    },
  });
});

/*****************************************************
 * ðŸ’° USER WALLET & WITHDRAWALS
 *****************************************************/
app.get("/api/user/:username", async (req, res) => {
  const { username } = req.params;
  const user = await db.get(
    "SELECT fullname, email, country, phone, created_at FROM users WHERE username = ?",
    [username]
  );
  if (!user) return res.status(404).json({ success: false, message: "User not found" });
  res.json({ success: true, user });
});

app.get("/api/wallet/:username", async (req, res) => {
  const { username } = req.params;
  const wallet = await db.get(
    "SELECT total_balance, affiliate_balance, bonus_balance FROM users WHERE username = ?",
    [username]
  );
  if (!wallet) return res.status(404).json({ success: false, message: "User not found" });
  res.json({ success: true, wallet });
});

app.post("/api/withdraw", async (req, res) => {
  try {
    const { username, amount, bank_name, account_number } = req.body;
    if (!username || !amount || !bank_name || !account_number)
      return res.status(400).json({ success: false, message: "Missing fields" });

    const user = await db.get(
      "SELECT total_balance, email FROM users WHERE username = ?",
      [username]
    );
    if (!user) return res.json({ success: false, message: "User not found" });

    if (amount > user.total_balance) {
      return res.json({ success: false, message: "Insufficient balance" });
    }

    const newBalance = user.total_balance - amount;
    await db.run("UPDATE users SET total_balance = ? WHERE username = ?", [newBalance, username]);

    await db.run(
      "INSERT INTO withdrawals (username, amount, bank_name, account_number, requested_at) VALUES (?, ?, ?, ?, ?)",
      [username, amount, bank_name, account_number, Date.now()]
    );

    await db.run(
      "INSERT INTO transactions (username, type, amount, balance_after, note, created_at) VALUES (?, ?, ?, ?, ?, ?)",
      [username, "withdraw_request", -amount, newBalance, "User withdrawal requested", Date.now()]
    );

    await db.run(
      "INSERT INTO wallet_logs (username, amount, type, description, created_at) VALUES (?, ?, ?, ?, ?)",
      [username, -amount, "debit", "Withdrawal request submitted", Date.now()]
    );

    res.json({ success: true, message: "Withdrawal request submitted successfully!" });
  } catch (err) {
    console.error("Withdraw error:", err);
    res.status(500).json({ success: false, message: "Server error" });
  }
});

/*****************************************************
 * ðŸ§‘â€ðŸ’¼ ADMIN WITHDRAWAL MANAGEMENT
 *****************************************************/
app.get("/api/admin/withdrawals", adminAuth, async (req, res) => {
  const status = req.query.status;
  const rows = status
    ? await db.all("SELECT * FROM withdrawals WHERE status = ? ORDER BY requested_at DESC", [status])
    : await db.all("SELECT * FROM withdrawals ORDER BY requested_at DESC");
  res.json({ success: true, withdrawals: rows });
});

app.post("/api/admin/withdrawals/update", adminAuth, async (req, res) => {
  try {
    const { id, status } = req.body;
    if (!id || !status) return res.json({ success: false, message: "Missing data" });

    const w = await db.get("SELECT * FROM withdrawals WHERE id = ?", [id]);
    if (!w) return res.json({ success: false, message: "Withdrawal not found" });

    await db.run("UPDATE withdrawals SET status = ? WHERE id = ?", [status, id]);

    const user = await db.get("SELECT email, fullname FROM users WHERE username = ?", [w.username]);
    if (user && user.email) {
      const subject = `Withdrawal Request #${id} ${status}`;
      const html = `
        <div>
          <p>Hello ${user.fullname || w.username},</p>
          <p>Your withdrawal request of â‚¦${Number(w.amount).toFixed(2)} has been <strong>${status}</strong>.</p>
          <p>Bank: ${w.bank_name} â€” Account: ${w.account_number}</p>
          <p>Thank you.</p>
        </div>
      `;
      sendEmail(user.email, subject, html).catch(err => console.error("Email error:", err));
    }

    await db.run(
      "INSERT INTO transactions (username, type, amount, balance_after, note, created_at) VALUES (?, ?, ?, ?, ?, ?)",
      [w.username, `withdraw_${status}`, 0, null, `Withdrawal ${status}`, Date.now()]
    );

    res.json({ success: true, message: `Withdrawal ${status}` });
  } catch (err) {
    console.error("Admin update error:", err);
    res.status(500).json({ success: false, message: "Server error" });
  }
});

/*****************************************************
 * ðŸ“œ USER TRANSACTION HISTORY & WALLET LOGS
 *****************************************************/
app.get("/api/transactions/:username", async (req, res) => {
  const { username } = req.params;
  try {
    const withdrawals = await db.all(
      "SELECT id, amount, status, requested_at AS date, 'Withdrawal' AS type FROM withdrawals WHERE username = ? ORDER BY requested_at DESC",
      [username]
    );

    const walletLogs = await db.all(
      "SELECT id, amount, type, description, created_at AS date FROM wallet_logs WHERE username = ? ORDER BY created_at DESC",
      [username]
    );

    res.json({
      success: true,
      transactions: [...withdrawals, ...walletLogs].sort(
        (a, b) => new Date(b.date) - new Date(a.date)
      ),
    });
  } catch (err) {
    console.error("Error fetching transactions:", err);
    res.status(500).json({ success: false, message: "Server error" });
  }
});

app.get("/api/wallet/logs/:username", async (req, res) => {
  const { username } = req.params;
  try {
    const logs = await db.all(
      "SELECT id, amount, type, description, created_at FROM wallet_logs WHERE username = ? ORDER BY created_at DESC",
      [username]
    );
    res.json({ success: true, logs });
  } catch (err) {
    console.error("Error fetching wallet logs:", err);
    res.status(500).json({ success: false, message: "Server error" });
  }
});

/*****************************************************
 * ðŸš€ START SERVER
 *****************************************************/
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`ðŸš€ Server running at http://localhost:${PORT}`));
